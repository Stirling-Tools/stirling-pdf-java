/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
package org.openapis.openapi.models.components;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.core.type.TypeReference;
import jakarta.annotation.Nonnull;
import jakarta.annotation.Nullable;
import java.lang.Boolean;
import java.lang.Override;
import java.lang.String;
import java.util.List;
import java.util.Optional;
import org.openapis.openapi.utils.LazySingletonValue;
import org.openapis.openapi.utils.SpeakeasyMetadata;
import org.openapis.openapi.utils.Utils;


public class MergePdfsRequest {
    /**
     * The input PDF files
     */
    @SpeakeasyMetadata("multipartForm:file,name=fileInput")
    private List<MergePdfsRequestFileInput> fileInput;

    /**
     * The type of sorting to be applied on the input files before merging.
     */
    @SpeakeasyMetadata("multipartForm:name=sortType")
    private SortType sortType;

    /**
     * Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document.
     */
    @SpeakeasyMetadata("multipartForm:name=removeCertSign")
    private Boolean removeCertSign;

    /**
     * Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names.
     */
    @SpeakeasyMetadata("multipartForm:name=generateToc")
    private Boolean generateToc;

    @JsonCreator
    public MergePdfsRequest(
            @Nonnull List<MergePdfsRequestFileInput> fileInput,
            @Nullable SortType sortType,
            @Nullable Boolean removeCertSign,
            @Nullable Boolean generateToc) {
        this.fileInput = Optional.ofNullable(fileInput)
            .orElseThrow(() -> new IllegalArgumentException("fileInput cannot be null"));
        this.sortType = Optional.ofNullable(sortType)
            .orElse(Builder._SINGLETON_VALUE_SortType.value());
        this.removeCertSign = Optional.ofNullable(removeCertSign)
            .orElse(Builder._SINGLETON_VALUE_RemoveCertSign.value());
        this.generateToc = Optional.ofNullable(generateToc)
            .orElse(Builder._SINGLETON_VALUE_GenerateToc.value());
    }
    
    public MergePdfsRequest(
            @Nonnull List<MergePdfsRequestFileInput> fileInput) {
        this(fileInput, null, null,
            null);
    }

    /**
     * The input PDF files
     */
    public List<MergePdfsRequestFileInput> fileInput() {
        return this.fileInput;
    }

    /**
     * The type of sorting to be applied on the input files before merging.
     */
    public Optional<SortType> sortType() {
        return Optional.ofNullable(this.sortType);
    }

    /**
     * Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document.
     */
    public Optional<Boolean> removeCertSign() {
        return Optional.ofNullable(this.removeCertSign);
    }

    /**
     * Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names.
     */
    public Optional<Boolean> generateToc() {
        return Optional.ofNullable(this.generateToc);
    }

    public static Builder builder() {
        return new Builder();
    }


    /**
     * The input PDF files
     */
    public MergePdfsRequest withFileInput(@Nonnull List<MergePdfsRequestFileInput> fileInput) {
        this.fileInput = Utils.checkNotNull(fileInput, "fileInput");
        return this;
    }


    /**
     * The type of sorting to be applied on the input files before merging.
     */
    public MergePdfsRequest withSortType(@Nullable SortType sortType) {
        this.sortType = sortType;
        return this;
    }


    /**
     * Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document.
     */
    public MergePdfsRequest withRemoveCertSign(@Nullable Boolean removeCertSign) {
        this.removeCertSign = removeCertSign;
        return this;
    }


    /**
     * Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names.
     */
    public MergePdfsRequest withGenerateToc(@Nullable Boolean generateToc) {
        this.generateToc = generateToc;
        return this;
    }


    @Override
    public boolean equals(java.lang.Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        MergePdfsRequest other = (MergePdfsRequest) o;
        return 
            Utils.enhancedDeepEquals(this.fileInput, other.fileInput) &&
            Utils.enhancedDeepEquals(this.sortType, other.sortType) &&
            Utils.enhancedDeepEquals(this.removeCertSign, other.removeCertSign) &&
            Utils.enhancedDeepEquals(this.generateToc, other.generateToc);
    }
    
    @Override
    public int hashCode() {
        return Utils.enhancedHash(
            fileInput, sortType, removeCertSign,
            generateToc);
    }
    
    @Override
    public String toString() {
        return Utils.toString(MergePdfsRequest.class,
                "fileInput", fileInput,
                "sortType", sortType,
                "removeCertSign", removeCertSign,
                "generateToc", generateToc);
    }

    @SuppressWarnings("UnusedReturnValue")
    public final static class Builder {

        private List<MergePdfsRequestFileInput> fileInput;

        private SortType sortType;

        private Boolean removeCertSign;

        private Boolean generateToc;

        private Builder() {
          // force use of static builder() method
        }

        /**
         * The input PDF files
         */
        public Builder fileInput(@Nonnull List<MergePdfsRequestFileInput> fileInput) {
            this.fileInput = Utils.checkNotNull(fileInput, "fileInput");
            return this;
        }

        /**
         * The type of sorting to be applied on the input files before merging.
         */
        public Builder sortType(@Nullable SortType sortType) {
            this.sortType = sortType;
            return this;
        }

        /**
         * Flag indicating whether to remove certification signatures from the merged PDF. If true, all certification signatures will be removed from the final merged document.
         */
        public Builder removeCertSign(@Nullable Boolean removeCertSign) {
            this.removeCertSign = removeCertSign;
            return this;
        }

        /**
         * Flag indicating whether to generate a table of contents for the merged PDF. If true, a table of contents will be created using the input filenames as chapter names.
         */
        public Builder generateToc(@Nullable Boolean generateToc) {
            this.generateToc = generateToc;
            return this;
        }

        public MergePdfsRequest build() {
            return new MergePdfsRequest(
                fileInput, sortType, removeCertSign,
                generateToc);
        }


        private static final LazySingletonValue<SortType> _SINGLETON_VALUE_SortType =
                new LazySingletonValue<>(
                        "sortType",
                        "\"orderProvided\"",
                        new TypeReference<SortType>() {});

        private static final LazySingletonValue<Boolean> _SINGLETON_VALUE_RemoveCertSign =
                new LazySingletonValue<>(
                        "removeCertSign",
                        "true",
                        new TypeReference<Boolean>() {});

        private static final LazySingletonValue<Boolean> _SINGLETON_VALUE_GenerateToc =
                new LazySingletonValue<>(
                        "generateToc",
                        "false",
                        new TypeReference<Boolean>() {});
    }
}
